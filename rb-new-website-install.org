#   -*- mode: org; fill-column: 60 -*-
#+TITLE: Creating a new static website
#+STARTUP: showall
#+PROPERTY: filename 
  :PROPERTIES:
  :Name: /home/deerpig/proj/deerpig/deerpig-install/jekyll-new-site.org
  :Created: 2016-06-29T12:12@Wat Phnom (11.5733N17-104.925295W)
  :ID: 33bde4be-47a5-4665-a2ce-ba85a59639df
  :URL:
  :END:


* Introduction

This document describes how to create a new static web site
using either org-publish or jekyll on Debian.

First install Apache2 and a Virtual Host for the new site:

  See: [[./rb-lamp-server.org][Lamp Server Runbook]].

Second, create A record for the subdomain that points to
site:

#+begin_example
A  site.example.com   10.0.0.100  1
#+end_example

* On Remote server

Create a directory called =repo= in a user account and a
directory for the new git repo and then do a git init.

#+begin_src sh
mkdir -p ~/repos/site.example.com
cd ./site.example.com
git init --bare
#+end_src

Then create a new file in ./hooks called /post-receive/
which will either automatically build the website and move
the files to =document root= using jekyll or =rsync= to copy
the files to =document root=.

#+begin_src sh
emacs ~/repo/site.example.com/hooks/post-receive
#+end_src

File: *~/repo/site.example.com/hooks/post-receive*

** Jekyll Site

For Jekyll Sites, use the following:

#+begin_source sh
#!/bin/bash -l
GIT_REPO=$HOME/repos/site.example.com
TMP_GIT_CLONE=$HOME/tmp/site.example.com
# For Jekyll site, use site-www/public_html
PUBLIC_WWW=/var/www/html/site.example.com/public_html

git clone $GIT_REPO $TMP_GIT_CLONE

# Use Jekyll to build the site and copy files to document root
jekyll build --source $TMP_GIT_CLONE --destination $PUBLIC_WWW

# Delete tmp files
rm -Rf $TMP_GIT_CLONE
exit
#+end_source

** Static Site

For Static Sites, use the following:

#+begin_source sh
#!/bin/bash -l
GIT_REPO=$HOME/repos/site.example.com
TMP_GIT_CLONE=$HOME/tmp/site.example.com
# For rsync site, use  site-www/public_html
PUBLIC_WWW=/var/www/html/site.example.com/public_html

git clone $GIT_REPO $TMP_GIT_CLONE

# Use rsync to copy files to document root
#rsync -avzh  $TMP_GIT_CLONE $PUBLIC_WWW

# Delete tmp files
rm -Rf $TMP_GIT_CLONE
exit
#+end_source



Make the file executable.

#+begin_src sh
sudo chmod +x post-receive
#+end_src

Create web server directories.

If you followed the directions in the Lamp Runbook then you
you can skip this step.

#+begin_src sh
sudo mkdir -p /var/www/html/site.example.com/public_html
sudo chown -R deerpig /var/www/html/site.example.com/public_html
#+end_src 

* On Local Machine

#+begin_src sh
mkdir ~/blog/site
cd ~/blog/site
jekyll new site-www
mkdir ./html
cd ./site-www
git init
git add .
git commit -m "added files"

git remote add deploy deerpig@example.com:~/repos/site-www
#+end_src

----

Now manage staging and commits in magit in emacs.  When you Push from
Magit it will run the deployment script on the server which
automatically invokes Jekyll and builds the site from git the Git repo.

Alternately, you can deploy, (push changes and rebuild jekyll) using
bash:

#+begin_src sh
git push deploy master
#+end_src

* Create Deploy Script

*Rethinking the existing deploy method*

The system I've been using is ugly -- that needs two repos
and a shell script for deploying.  We need to do this with
one repo and one hook:

#+begin_ascii
org/jekyll src --> user@server:~/repo
  git repo-1            |     git hook
                        '--> rsync public_html to document_root
#+end_ascii

Or simply create a repo that holds both source and rendered
and then only sync the rendered directory... then we don't
need the deploy script.

  - site.example.com
    - src
    - public_html

    rsync -avzh  $HOME/tmp/site.example.com/public_html  $PUBLIC_WWW
    rm -Rf $TMP_GIT_CLONE

We want the src in version control, but not the rendered
files, but we want the rendered files moved to the server
using git....  will the ignored file still be copied when
merged?


-----

The way I have things set up, each site has two repos -- one
for the source files, and the other for the build file (the
static site rendered by either org-publish or jekyll).

Let's say you have a repo called =homer-org= for the org
source files and then =homer-www= for the generated site.

So you make changes to the site then commit, do a git add and
commit and push.  That saves the source files.  Then you
want to regenerate the site and deploy it on the web server
using either org-publish-project, or jekyll build.

With our configuration, git will commit the static site
locally, push the files to the server and then run a deploy
command that clones the repo into the web server directory.

On the local machine, this means that git commit will always
just be /deploying/ the site -- there is no need to describe
what changes have been made because this is already being
taken care of in the source repo.

So we write a script that builds the static site locally then
deploys using git add commit push.

#+begin_src sh
cd ~/bin
emacs <projectname>
#+end_src

And add the following:

#+begin_example
#!/bin/bash
# adds stages and pushes files in directory
SITE_SRC=$HOME/proj/dir/proj-src
SITE_BUILD=$HOME/proj/dir/proj-html

# make sure the script is in the path
export PATH=$PATH:/home/deerpig/bin/ ;

# change to build dir and fetch any changes from
# any deployment from other boxes
cd $SITE_BUILD && \
git pull deploy master && \

# Change to the src directory and build the site
# using org-publish or jekyll build
cd $SITE_SRC && \

# Uncomment if this is a org publish site
# All projects will be published
#/usr/local/bin/emacs --batch -l ~/.emacs -f org-publish-all && \
# Uncomment if this is a Jekyll site
jekyll build  && \

# Change back to the build dir and push to the server
cd $SITE_BUILD && \
git add . && \
git add -u && \
git commit -m "deploy" && \
git push deploy master
exit
#+end_example

#+begin_src sh
chmod +x deploy.sh
#+end_src

I keep all the deploy scripts in my =.dotfiles= directory
which is synced between all the machines I use and then
create symbolic links to ~/bin/.

#+begin_src sh
cd ~/bin/
ln -s ../.dotfiles/deploy.sh deploy-<site>
#+end_src

** Create Emacs Deploy Function

You can run the deploy scripts from any bash prompt, but
then we would have to leave emacs to do that.  Admit it,
that really is not acceptable, it breaks some kind of
natural law or something.

So let's write a short function to bring up an interactive
menu so you can choose which site to deploy...

Put this somewhere in your .emacs or init file.

#+begin_quote emacs-lisp
;; Deploy projects
(defun deploy (name)
  "Build and deploy local websites using shell script to call
   orgmode and git.  Scripts are kept in ~/.dotfiles/ and
   linked to ~/bin/"
  (interactive "cdeploy: (c)ore (l)a (d)eerpig")
  (shell-command     (cond ((equal name ?c) "cored")
			   ((equal name ?l) "betad")
			   ((equal name ?d) "deerd"))))
#+end_quote

* Workflow

Putting it all together, we get the following workflow:

 - Edit files, save
 - Magit-status
 - Stage/Commit
 - Push deploy 

If you are running Jekyll on the server to build the site
then you're done.  But if you are using org-publish or are
using jekyll build locally, then:

 - M-x deploy (to run the deploy shell script for the site).

* Set up Nikola

If you are not using Ruby every day, install Jekyll can be a
nightmare.  So let's try Nikola which is written in Python
to see if it might be a bit more sane install environment.

 - [[https://getnikola.com/getting-started.html][Getting Started | Nikola]]

First make sure you have at least python3, pip and
virtualenv installed.

#+begin_src sh 
sudo apt-get install python3 python-pip
#+end_src

check that you have python 3.x

#+begin_src sh
python3 --version
#+end_src

Install virtualenv and  virtualenvwrapper

#+begin_src sh
sudo pip install virtualenv --upgrade
sudo pip install virtualenvwrapper
#+end_src

Add the following to your .bashrc

#+begin_src sh
export WORKON_HOME=${HOME}/proj/lala
if [ -f /usr/local/bin/virtualenvwrapper.sh ]; then
    source /usr/local/bin/virtualenvwrapper.sh
elif [ -f /usr/bin/virtualenvwrapper.sh ]; then
   source /usr/bin/virtualenvwrapper.sh
fi
#+end_src

Reload .bashrc

#+begin_src sh
source ~/.bashrc
#+end_src

Create a local directory for a project and set up a
virtualdev project. I'm using ~/proj/lala

#+begin_src sh
mkdir ~/proj/lala
cd ~/proj/lala

virtualenv -p /usr/bin/python3 nikola
cd nikola
workon nikola
pip install --upgrade setuptools pip
pip install --upgrade "Nikola[extras]"
#+end_src

Use the cmd 'deactivate' to escape from the virtualenv and
then 'workon' to choose which env you want to work in.

