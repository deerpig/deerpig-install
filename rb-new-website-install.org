#   -*- mode: org; fill-column: 60 -*-
#+TITLE: Creating a new static website
#+STARTUP: showall
#+PROPERTY: filename 
  :PROPERTIES:
  :Name: /home/deerpig/proj/deerpig/deerpig-install/jekyll-new-site.org
  :Created: 2016-06-29T12:12@Wat Phnom (11.5733N17-104.925295W)
  :ID: 33bde4be-47a5-4665-a2ce-ba85a59639df
  :URL:
  :END:
#+INCLUDE: ./inc/head.org
#+INCLUDE: ./inc/macros.org
#+INCLUDE: ./inc/links.org

{{{breadcrumbs}}}

#+HTML: <div class="outline-2" id="meta">
| *Author*  | Brad Collins <brad@chenla.org>             |
| *Date*    | {{{time(%Y-%m-%d %H:%M:%S)}}}              |
#+HTML: </div>

#+TOC: headlines 4

* Status of This Document

The latest version of this document is: src_sh[:results value]{git describe --abbrev=0 --tags}

#+HTML: <div class="notice notice-info">
*Changes since the last version*

#+HTML: <ul>

#+BEGIN_SRC sh :exports results :results value html :var TAG="v00.01.02"
  RES=`git log $TAG...HEAD --pretty="<li>%s</li>\n" -- rb-new-website-install.org`
  if [ -z $RES ]; then
    RES="<li>no changes</li>"
  fi
  echo $RES
#+END_SRC

#+RESULTS:
#+BEGIN_EXPORT html
<li>no changes</li>
#+END_EXPORT

#+HTML: </ul>
#+HTML: </div>

* Introduction

This document describes how to create a new static web site
using either org-publish or jekyll on CentOS VM.

* Install Apache 2

#+begin_src sh
sudo apt-get install apache2
#+end_src

* Set up Apache Virtual Host

Create an Virtual Host in apache.

We keep our apache directives in a separate directory to
prevent apache from overwriting anything when we upgrade.

#+begin_src  sh
sudo emacs /etc/httpd/conf/domains/site-www.conf
#+end_src

#+begin_src sh
<VirtualHost *:80>
  ServerName site.chenla.org
  DocumentRoot /var/www/site-www/html
</VirtualHost>
#+end_src

Now restart apache.

#+begin_src sh
sudo systemctl restart httpd
#+end_src

Go to Directnic and create A record for the subdomain that
points to site.

#+begin_src sh
A  site.kinto-cloud.com   10.0.0.100  1
#+end_src


* On Remote server

SHH into the remove server and create the directory for the
new repo and then do a git init.  Then create a new file in
./hooks called /post-receive/ which will either automatically build
the website and move the files to =document root= using
jekyll or, if the site has already been built, use =rsync=
to copy the files to =document root=.


#+begin_src sh
ssh deerpig@dev.chenla.org
mkdir ~/repos/site-www
cd ./site-www
git init --bare
cd hooks
emacs post-receive
#+end_src

#+begin_src sh
#!/bin/bash -l
GIT_REPO=$HOME/repos/site-www
TMP_GIT_CLONE=$HOME/tmp/site-www
# For Jekyll site, use site-www/html
# For rsync site, ise  site-www/site-www
PUBLIC_WWW=/var/www/site-www/html

git clone $GIT_REPO $TMP_GIT_CLONE

# Use rsync to copy files to document root
#rsync -avzh  $TMP_GIT_CLONE $PUBLIC_WWW

# Use Jekyll to build the site and copy files to document root
jekyll build --source $TMP_GIT_CLONE --destination $PUBLIC_WWW

# Delete tmp files
rm -Rf $TMP_GIT_CLONE
exit
#+end_src

#+begin_src sh
sudo chmod +x post-receive
#+end_src

#+begin_src sh
sudo mkdir -p /var/www/site/html
sudo chown -R deerpig /var/www/site
#+end_src 

* On Local Machine

#+begin_src sh
mkdir ~/blog/site
cd ~/blog/site
jekyll new site-www
mkdir ./html
cd ./site-www
git init
git add .
git commit -m "added files"

git remote add deploy deerpig@camby.kinto-cloud.com:~/repos/site-www
#+end_src

----

Now manage staging and commits in magit in emacs.  When you Push from
Magit it will run the deployment script on the server which
automatically invokes Jekyll and builds the site from git the Git repo.

Alternately, you can deploy, (push changes and rebuild jekyll) using
bash:

#+begin_src sh
git push deploy master
#+end_src

* Create Deploy Script

The way I have things set up, it that each site has two
repos -- one for the source files, and the other for the
build file (the static site rendered by either org-publish
or jekyll).

Let's say you have a repo called =homer-org= for the org
source files and then =homer-www= for the generated site.

So you make changes to the site then commit, do a git add and
commit and push.  That saves the source files.  Then you
want to regenerate the site and deploy it on the web server
using either org-publish-project, or jekyll build.

With our configuration, git will commit the static site
locally, push the files to the server and then run a deploy
command that clones the repo into the web server directory.

On the local machine, this means that git commit will always
just be /deploying/ the site -- there is no need to describe
what changes have been made because this is already being
taken care of in the source repo.

So we write a script that builds the static site locally then
deploys using git add commit push.

#+begin_src sh
cd ~/bin
emacs <projectname>
#+end_src

And add the following:

#+begin_src sh
#!/bin/bash
# adds stages and pushes files in directory
SITE_SRC=$HOME/proj/dir/proj-src
SITE_BUILD=$HOME/proj/dir/proj-html

# make sure the script is in the path
export PATH=$PATH:/home/deerpig/bin/ ;

# change to build dir and fetch any changes from
# any deployment from other boxes
cd $SITE_BUILD && \
git pull deploy master && \

# Change to the src directory and build the site
# using org-publish or jekyll build
cd $SITE_SRC && \

# Uncomment if this is a org publish site
# All projects will be published
#/usr/local/bin/emacs --batch -l ~/.emacs -f org-publish-all && \
# Uncomment if this is a Jekyll site
jekyll build  && \

# Change back to the build dir and push to the server
cd $SITE_BUILD && \
git add . && \
git add -u && \
git commit -m "deploy" && \
git push deploy master
exit
#+end_src

#+begin_src sh
chmod +x deploy.sh
#+end_src

I keep all the deploy scripts in my =.dotfiles= directory
which is synced between all the machines I use and then
create symbolic links to ~/bin/.

#+begin_src sh
cd ~/bin/
ln -s ../.dotfiles/deploy.sh deploy-<site>
#+end_src

** Create Emacs Deploy Function

You can run the deploy scripts from any bash prompt, but
then we would have to leave emacs to do that.  Admit it,
that really is not acceptable, it breaks some kind of
natural law or something.

So let's write a short function to bring up an interactive
menu so you can choose which site to deploy...

Put this somewhere in your .emacs or init file.

#+begin_quote emacs-lisp
;; Deploy projects
(defun deploy (name)
  "Build and deploy local websites using shell script to call
   orgmode and git.  Scripts are kept in ~/.dotfiles/ and
   linked to ~/bin/"
  (interactive "cdeploy: (c)ore (l)a (d)eerpig")
  (shell-command     (cond ((equal name ?c) "cored")
			   ((equal name ?l) "betad")
			   ((equal name ?d) "deerd"))))
#+end_quote

* Workflow

Putting it all together, we get the following workflow:

 - Edit files, save
 - Magit-status
 - Stage/Commit
 - Push deploy 

If you are running Jekyll on the server to build the site
then you're done.  But if you are using org-publish or are
using jekyll build locally, then:

 - M-x deploy (to run the deploy shell script for the site).

* Set up Nikola

If you are not using Ruby every day, install Jekyll can be a
nightmare.  So let's try Nikola which is written in Python
to see if it might be a bit more sane install environment.

 - [[https://getnikola.com/getting-started.html][Getting Started | Nikola]]

First make sure you have at least python3, pip and
virtualenv installed.

#+begin_src sh 
sudo apt-get install python3 python-pip
#+end_src

check that you have python 3.x

#+begin_src sh
python3 --version
#+end_src

Install virtualenv and  virtualenvwrapper

#+begin_src sh
sudo pip install virtualenv --upgrade
sudo pip install virtualenvwrapper
#+end_src

Add the following to your .bashrc

#+begin_src sh
export WORKON_HOME=${HOME}/proj/lala
if [ -f /usr/local/bin/virtualenvwrapper.sh ]; then
    source /usr/local/bin/virtualenvwrapper.sh
elif [ -f /usr/bin/virtualenvwrapper.sh ]; then
   source /usr/bin/virtualenvwrapper.sh
fi
#+end_src

Reload .bashrc

#+begin_src sh
source ~/.bashrc
#+end_src

Create a local directory for a project and set up a
virtualdev project. I'm using ~/proj/lala

#+begin_src sh
mkdir ~/proj/lala
cd ~/proj/lala

virtualenv -p /usr/bin/python3 nikola
cd nikola
workon nikola
pip install --upgrade setuptools pip
pip install --upgrade "Nikola[extras]"
#+end_src

Use the cmd 'deactivate' to escape from the virtualenv and
then 'workon' to choose which env you want to work in.

